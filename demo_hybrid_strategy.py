#!/usr/bin/env python3
"""
Demo de Estrategia H√≠brida de Datos
Demuestra el uso optimizado de base de datos y CSV seg√∫n el caso de uso
"""

import sys
import os
from pathlib import Path
from datetime import datetime, timedelta
import pandas as pd
import time

# Agregar src al path
sys.path.append(str(Path(__file__).parent / "src"))

from src.data.data_access_layer import DataAccessLayer
from src.data.data_strategy import DataStrategy, DataUsagePattern

def print_section(title: str):
    """Imprime una secci√≥n con formato."""
    print("\n" + "="*60)
    print(f" {title}")
    print("="*60)

def print_subsection(title: str):
    """Imprime una subsecci√≥n con formato."""
    print(f"\n--- {title} ---")

def demo_data_access_layer():
    """Demuestra la capa de acceso a datos h√≠brida."""
    print_section("DEMO: Data Access Layer - Acceso H√≠brido")
    
    # Inicializar capa de acceso
    dal = DataAccessLayer()
    
    print_subsection("1. Resumen del Estado Actual")
    summary = dal.get_data_summary()
    
    print("üìä Base de Datos:")
    for key, info in summary['database'].items():
        print(f"  ‚Ä¢ {key}: {info['records']} registros ({info['date_range']})")
    
    print("\nüìÅ Archivos CSV:")
    for key, info in summary['csv_files'].items():
        if isinstance(info, dict):
            print(f"  ‚Ä¢ {key}: {info['records']} registros, {info['file_size']}")
        else:
            print(f"  ‚Ä¢ {key}: {info}")
    
    print("\nüîÑ Estado de Sincronizaci√≥n:")
    for key, status in summary['sync_status'].items():
        status_icon = "‚úÖ" if status == "Sincronizado" else "‚ö†Ô∏è"
        print(f"  {status_icon} {key}: {status}")
    
    print("\nüí° Recomendaciones:")
    for rec in summary['recommendations']:
        print(f"  ‚Ä¢ {rec}")
    
    print_subsection("2. Sincronizaci√≥n de Datos")
    print("Sincronizando fuentes de datos...")
    sync_results = dal.sync_data_sources()
    
    for key, result in sync_results.items():
        result_icon = "‚úÖ" if "Sincronizado" in result else "‚ÑπÔ∏è"
        print(f"  {result_icon} {key}: {result}")
    
    return dal

def demo_realtime_trading(strategy: DataStrategy):
    """Demuestra estrategia para trading en tiempo real."""
    print_section("DEMO: Trading en Tiempo Real - M√°xima Velocidad")
    
    symbol = "BTCUSDT"
    interval = "1h"
    
    print(f"üöÄ Obteniendo datos para trading en tiempo real: {symbol} {interval}")
    print("   Prioridad: Cache ‚Üí Base de Datos ‚Üí CSV")
    
    start_time = time.time()
    data = strategy.get_data(
        pattern=DataUsagePattern.REALTIME_TRADING,
        symbol=symbol,
        interval=interval,
        limit=100
    )
    end_time = time.time()
    
    if not data.empty:
        print(f"\nüìà Datos obtenidos en {(end_time - start_time)*1000:.1f}ms")
        print(f"   ‚Ä¢ Registros: {len(data)}")
        print(f"   ‚Ä¢ √öltimo precio: ${data['close'].iloc[-1]:.2f}")
        print(f"   ‚Ä¢ Cambio de precio: {data['price_change'].iloc[-1]*100:.2f}%")
        print(f"   ‚Ä¢ Volumen promedio: {data['volume_ma'].iloc[-1]:,.0f}")
        
        # Mostrar √∫ltimos 3 registros
        print("\nüìä √öltimos 3 registros:")
        recent_data = data[['datetime', 'close', 'volume', 'price_change']].tail(3)
        for _, row in recent_data.iterrows():
            change_icon = "üìà" if row['price_change'] > 0 else "üìâ" if row['price_change'] < 0 else "‚û°Ô∏è"
            print(f"   {change_icon} {row['datetime']}: ${row['close']:.2f} (Vol: {row['volume']:,.0f})")
    else:
        print("‚ùå No se encontraron datos")

def demo_ml_training(strategy: DataStrategy):
    """Demuestra estrategia para entrenamiento de ML."""
    print_section("DEMO: Machine Learning - Datos Completos y Features")
    
    symbol = "BTCUSDT"
    interval = "1h"
    
    print(f"ü§ñ Obteniendo datos para entrenamiento ML: {symbol} {interval}")
    print("   Prioridad: CSV ‚Üí Base de Datos")
    print("   Incluye: Preprocesamiento + Feature Engineering")
    
    start_time = time.time()
    data = strategy.get_data(
        pattern=DataUsagePattern.ML_TRAINING,
        symbol=symbol,
        interval=interval,
        lookback_days=30,
        include_features=True
    )
    end_time = time.time()
    
    if not data.empty:
        print(f"\nüß† Datos preparados en {(end_time - start_time)*1000:.1f}ms")
        print(f"   ‚Ä¢ Registros: {len(data)}")
        print(f"   ‚Ä¢ Features: {len(data.columns)}")
        print(f"   ‚Ä¢ Rango de fechas: {data['datetime'].min()} a {data['datetime'].max()}")
        
        # Mostrar features disponibles
        print("\nüîß Features disponibles:")
        feature_cols = [col for col in data.columns if col not in ['datetime', 'timestamp']]
        for i, col in enumerate(feature_cols[:10]):  # Mostrar primeras 10
            print(f"   ‚Ä¢ {col}")
        if len(feature_cols) > 10:
            print(f"   ... y {len(feature_cols) - 10} m√°s")
        
        # Estad√≠sticas b√°sicas
        print("\nüìä Estad√≠sticas de returns:")
        if 'returns' in data.columns:
            returns = data['returns'].dropna()
            print(f"   ‚Ä¢ Media: {returns.mean()*100:.4f}%")
            print(f"   ‚Ä¢ Volatilidad: {returns.std()*100:.4f}%")
            print(f"   ‚Ä¢ Sharpe ratio: {returns.mean()/returns.std():.4f}")
        
        # Verificar calidad de datos
        if hasattr(data, 'attrs') and 'data_quality' in data.attrs:
            quality = data.attrs['data_quality']
            print(f"\n‚úÖ Calidad de datos: {quality['completeness']:.1f}% completo")
    else:
        print("‚ùå No se encontraron datos")

def demo_backtesting(strategy: DataStrategy):
    """Demuestra estrategia para backtesting."""
    print_section("DEMO: Backtesting - Datos Hist√≥ricos Completos")
    
    symbol = "BTCUSDT"
    interval = "1h"
    
    print(f"üìà Obteniendo datos para backtesting: {symbol} {interval}")
    print("   Prioridad: CSV ‚Üí Base de Datos")
    print("   Garantiza: Continuidad temporal + Datos completos")
    
    # Definir per√≠odo de backtesting
    end_date = datetime.now()
    start_date = end_date - timedelta(days=15)
    
    start_time = time.time()
    data = strategy.get_data(
        pattern=DataUsagePattern.BACKTESTING,
        symbol=symbol,
        interval=interval,
        start_date=start_date,
        end_date=end_date
    )
    end_time = time.time()
    
    if not data.empty:
        print(f"\n‚è±Ô∏è Datos cargados en {(end_time - start_time)*1000:.1f}ms")
        print(f"   ‚Ä¢ Registros: {len(data)}")
        print(f"   ‚Ä¢ Per√≠odo: {data['datetime'].min()} a {data['datetime'].max()}")
        
        # Verificar continuidad
        if len(data) > 1:
            time_diffs = data['datetime'].diff().dropna()
            median_diff = time_diffs.median()
            gaps = time_diffs[time_diffs > median_diff * 2]
            
            print(f"   ‚Ä¢ Intervalo t√≠pico: {median_diff}")
            print(f"   ‚Ä¢ Gaps detectados: {len(gaps)}")
        
        # Simular estrategia simple
        if 'forward_return' in data.columns:
            print("\nüéØ Simulaci√≥n de estrategia simple (Buy & Hold):")
            total_return = (data['close'].iloc[-1] / data['close'].iloc[0]) - 1
            print(f"   ‚Ä¢ Retorno total: {total_return*100:.2f}%")
            
            # Calcular m√©tricas b√°sicas
            if 'returns' in data.columns:
                returns = data['returns'].dropna()
                winning_trades = (returns > 0).sum()
                total_trades = len(returns)
                win_rate = winning_trades / total_trades if total_trades > 0 else 0
                
                print(f"   ‚Ä¢ Win rate: {win_rate*100:.1f}%")
                print(f"   ‚Ä¢ Mejor d√≠a: {returns.max()*100:.2f}%")
                print(f"   ‚Ä¢ Peor d√≠a: {returns.min()*100:.2f}%")
    else:
        print("‚ùå No se encontraron datos para el per√≠odo especificado")

def demo_api_serving(strategy: DataStrategy):
    """Demuestra estrategia para servir datos v√≠a API."""
    print_section("DEMO: API Serving - Respuestas R√°pidas y Formateadas")
    
    symbol = "ETHUSDT"
    interval = "1h"
    
    print(f"üåê Obteniendo datos para API: {symbol} {interval}")
    print("   Prioridad: Cache ‚Üí Base de Datos")
    print("   Formato: JSON-ready con precisi√≥n optimizada")
    
    start_time = time.time()
    data = strategy.get_data(
        pattern=DataUsagePattern.API_SERVING,
        symbol=symbol,
        interval=interval,
        limit=50,
        format_for_json=True
    )
    end_time = time.time()
    
    if not data.empty:
        print(f"\n‚ö° Respuesta API en {(end_time - start_time)*1000:.1f}ms")
        print(f"   ‚Ä¢ Registros: {len(data)}")
        print(f"   ‚Ä¢ Tama√±o estimado: {len(data.to_json())//1024:.1f} KB")
        
        # Mostrar formato de respuesta
        print("\nüìã Formato de respuesta (primeros 2 registros):")
        sample_data = data.head(2)
        for _, row in sample_data.iterrows():
            print(f"   {{")
            print(f"     'datetime': '{row['datetime']}',")
            print(f"     'open': {row['open']},")
            print(f"     'high': {row['high']},")
            print(f"     'low': {row['low']},")
            print(f"     'close': {row['close']},")
            print(f"     'volume': {row['volume']}")
            print(f"   }}")
            break  # Solo mostrar uno
        print("   ...")
    else:
        print("‚ùå No se encontraron datos")

def demo_dashboard(strategy: DataStrategy):
    """Demuestra estrategia para dashboards."""
    print_section("DEMO: Dashboard - Visualizaci√≥n con Agregaciones")
    
    symbol = "BTCUSDT"
    interval = "1h"
    
    print(f"üìä Obteniendo datos para dashboard: {symbol} {interval}")
    print("   Incluye: SMA, Bollinger Bands, Volumen promedio")
    
    start_time = time.time()
    data = strategy.get_data(
        pattern=DataUsagePattern.DASHBOARD,
        symbol=symbol,
        interval=interval,
        include_aggregations=True
    )
    end_time = time.time()
    
    if not data.empty:
        print(f"\nüìà Datos para dashboard en {(end_time - start_time)*1000:.1f}ms")
        print(f"   ‚Ä¢ Registros: {len(data)}")
        
        # Mostrar indicadores calculados
        latest = data.iloc[-1]
        print("\nüìä Indicadores actuales:")
        print(f"   ‚Ä¢ Precio: ${latest['close']:.2f}")
        
        if 'sma_20' in data.columns and pd.notna(latest['sma_20']):
            print(f"   ‚Ä¢ SMA 20: ${latest['sma_20']:.2f}")
            trend = "üìà Alcista" if latest['close'] > latest['sma_20'] else "üìâ Bajista"
            print(f"   ‚Ä¢ Tendencia: {trend}")
        
        if 'bb_upper' in data.columns and pd.notna(latest['bb_upper']):
            bb_position = (latest['close'] - latest['bb_lower']) / (latest['bb_upper'] - latest['bb_lower'])
            print(f"   ‚Ä¢ Posici√≥n en BB: {bb_position*100:.1f}%")
        
        if 'volume_sma' in data.columns and pd.notna(latest['volume_sma']):
            vol_ratio = latest['volume'] / latest['volume_sma']
            vol_status = "üî• Alto" if vol_ratio > 1.5 else "üìä Normal" if vol_ratio > 0.5 else "üí§ Bajo"
            print(f"   ‚Ä¢ Volumen: {vol_status} ({vol_ratio:.1f}x promedio)")
        
        # Contar indicadores disponibles
        indicators = [col for col in data.columns if col.startswith(('sma_', 'bb_', 'volume_'))]
        print(f"\nüîß Indicadores disponibles: {len(indicators)}")
        for indicator in indicators[:5]:  # Mostrar primeros 5
            print(f"   ‚Ä¢ {indicator}")
    else:
        print("‚ùå No se encontraron datos")

def demo_performance_comparison():
    """Compara rendimiento entre diferentes estrategias."""
    print_section("DEMO: Comparaci√≥n de Rendimiento")
    
    dal = DataAccessLayer()
    strategy = DataStrategy(dal)
    
    symbol = "BTCUSDT"
    interval = "1h"
    limit = 100
    
    patterns_to_test = [
        DataUsagePattern.REALTIME_TRADING,
        DataUsagePattern.ML_TRAINING,
        DataUsagePattern.API_SERVING
    ]
    
    print(f"‚ö° Comparando rendimiento para {symbol} {interval} (l√≠mite: {limit})")
    print("\nüèÅ Resultados:")
    
    results = []
    for pattern in patterns_to_test:
        start_time = time.time()
        data = strategy.get_data(
            pattern=pattern,
            symbol=symbol,
            interval=interval,
            limit=limit
        )
        end_time = time.time()
        
        duration_ms = (end_time - start_time) * 1000
        results.append({
            'pattern': pattern.value,
            'duration_ms': duration_ms,
            'records': len(data) if not data.empty else 0,
            'columns': len(data.columns) if not data.empty else 0
        })
        
        print(f"   ‚Ä¢ {pattern.value:20} {duration_ms:6.1f}ms  {len(data):3d} registros  {len(data.columns):2d} columnas")
    
    # Encontrar el m√°s r√°pido
    fastest = min(results, key=lambda x: x['duration_ms'])
    print(f"\nüèÜ M√°s r√°pido: {fastest['pattern']} ({fastest['duration_ms']:.1f}ms)")

def main():
    """Funci√≥n principal del demo."""
    print("üöÄ DEMO: Estrategia H√≠brida de Datos para Trading")
    print("   Optimizaci√≥n inteligente seg√∫n el caso de uso")
    
    try:
        # 1. Inicializar sistema
        dal = demo_data_access_layer()
        strategy = DataStrategy(dal)
        
        # 2. Mostrar informaci√≥n de estrategias
        print_section("ESTRATEGIAS DISPONIBLES")
        strategies_info = strategy.get_strategy_info()
        for pattern_name, info in strategies_info.items():
            print(f"\nüéØ {pattern_name.upper()}:")
            print(f"   ‚Ä¢ {info['description']}")
            print(f"   ‚Ä¢ Prioridad: {' ‚Üí '.join(info['data_source_priority'])}")
            print(f"   ‚Ä¢ Optimizaciones: {', '.join(info['optimizations'])}")
        
        # 3. Demos espec√≠ficos
        demo_realtime_trading(strategy)
        demo_ml_training(strategy)
        demo_backtesting(strategy)
        demo_api_serving(strategy)
        demo_dashboard(strategy)
        
        # 4. Comparaci√≥n de rendimiento
        demo_performance_comparison()
        
        print_section("RESUMEN Y RECOMENDACIONES")
        print("‚úÖ Demo completado exitosamente")
        print("\nüí° Recomendaciones de uso:")
        print("   ‚Ä¢ Trading en tiempo real: Usa REALTIME_TRADING para m√≠nima latencia")
        print("   ‚Ä¢ Entrenamiento ML: Usa ML_TRAINING para features completas")
        print("   ‚Ä¢ Backtesting: Usa BACKTESTING para datos hist√≥ricos completos")
        print("   ‚Ä¢ APIs: Usa API_SERVING para respuestas optimizadas")
        print("   ‚Ä¢ Dashboards: Usa DASHBOARD para visualizaciones enriquecidas")
        
        print("\nüîÑ Mantenimiento:")
        print("   ‚Ä¢ Ejecuta sync_data_sources() regularmente")
        print("   ‚Ä¢ Monitorea el rendimiento de cache")
        print("   ‚Ä¢ Revisa recomendaciones del sistema")
        
    except Exception as e:
        print(f"\n‚ùå Error durante el demo: {str(e)}")
        print("\nüîß Posibles soluciones:")
        print("   ‚Ä¢ Verifica que la base de datos existe (trading.db)")
        print("   ‚Ä¢ Aseg√∫rate de que hay datos hist√≥ricos disponibles")
        print("   ‚Ä¢ Ejecuta primero: python src/data/data_manager.py")
        raise

if __name__ == "__main__":
    main()